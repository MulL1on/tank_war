// Code generated by hertz generator.

package room

import (
	"context"
	"encoding/json"
	"github.com/bwmarrin/snowflake"
	"github.com/cloudwego/hertz/pkg/app"
	"github.com/cloudwego/hertz/pkg/common/hlog"
	"github.com/go-redis/redis/v8"
	"github.com/hashicorp/consul/api"
	"net"
	"net/http"
	"strconv"
	"tank_war/server/cmd/api/biz/model/base"
	"tank_war/server/cmd/api/biz/model/room"
	"tank_war/server/cmd/api/config"
	"tank_war/server/shared/consts"
	"tank_war/server/shared/kitex_gen/user"
)

// CreateRoom .
// @router /room [POST]
func CreateRoom(ctx context.Context, c *app.RequestContext) {
	var err error
	var req room.CreateRoomReq
	err = c.BindAndValidate(&req)
	if err != nil {
		c.String(http.StatusBadRequest, err.Error())
		return
	}
	resp := new(room.CreateRoomResp)

	//validate room capacity
	if req.MaxPlayer < 2 || req.MaxPlayer > 4 {
		c.String(http.StatusBadRequest, "room capacity must be 2-4")
		return
	}

	uidStr := c.MustGet("uid").(string)
	if uidStr == "" {
		c.String(http.StatusBadRequest, "uid is empty")
		return
	}
	uid, err := strconv.ParseInt(uidStr, 10, 64)
	if err != nil {
		c.String(http.StatusBadRequest, "uid is invalid")
		return
	}

	//get username
	kuser, err := config.GlobalUserClient.GetUserInfo(ctx, &user.GetUserInfoReq{UserId: uid})
	if err != nil {
		c.String(http.StatusBadRequest, err.Error())
		return
	}

	//get room from redis
	err = config.Rdb.HGet(ctx, consts.Room, req.Name).Err()
	if err != nil {
		if err != redis.Nil {
			c.String(http.StatusInternalServerError, err.Error())
			return
		}
	} else {
		c.String(http.StatusBadRequest, "room name already exists")
		return
	}

	r := base.Room{
		Name:          req.Name,
		MaxPlayer:     req.MaxPlayer,
		CurrentPlayer: 0,
	}

	cfg := api.DefaultConfig()
	cfg.Address = net.JoinHostPort(
		config.GlobalConsulConfig.Host,
		strconv.Itoa(config.GlobalConsulConfig.Port))

	client, err := api.NewClient(cfg)

	if err != nil {
		c.String(http.StatusInternalServerError, err.Error())
		return
	}

	sf, err := snowflake.NewNode(4)
	if err != nil {
		c.String(http.StatusInternalServerError, err.Error())
		return
	}

	services, _, err := client.Health().Service(consts.GameServer, "", true, nil)
	if err != nil {
		c.String(http.StatusInternalServerError, err.Error())
		return
	}

	for _, service := range services {
		if service.Service.Meta["status"] == "free" {
			r.Host = service.Service.Address
			r.Port = int32(service.Service.Port)
			r.RoomID = sf.Generate().Int64()

			//保存房间信息到redis
			jsonData, err := json.Marshal(r)
			if err != nil {
				c.String(http.StatusInternalServerError, err.Error())
				return
			}

			err = config.Rdb.HSet(ctx, consts.Room, req.Name, jsonData).Err()
			if err != nil {
				c.String(http.StatusInternalServerError, err.Error())
				return
			}

			resp.RoomID = r.RoomID
			resp.Address = r.Host
			resp.Port = r.Port
			resp.PlayerID = uid
			resp.PlayerName = kuser.User.Username
			resp.MaxPlayer = r.MaxPlayer
			resp.RoomName = r.Name
			c.JSON(http.StatusOK, resp)
			return
		}
	}
	c.JSON(http.StatusInternalServerError, "game server not found")
}

// JoinRoom .
// @router /room/join [POST]
func JoinRoom(ctx context.Context, c *app.RequestContext) {
	var err error
	var req room.JoinRoomReq
	err = c.BindAndValidate(&req)
	if err != nil {
		c.String(http.StatusBadRequest, err.Error())
		return
	}
	uidStr := c.MustGet("uid").(string)
	if uidStr == "" {
		c.String(http.StatusBadRequest, "uid is empty")
		return
	}
	uid, err := strconv.ParseInt(uidStr, 10, 64)
	if err != nil {
		c.String(http.StatusBadRequest, "uid is invalid")
		return
	}

	//get username
	kuser, err := config.GlobalUserClient.GetUserInfo(ctx, &user.GetUserInfoReq{UserId: uid})
	if err != nil {
		c.String(http.StatusBadRequest, err.Error())
		return
	}

	r := &base.Room{}
	//get room from redis
	jsonData, err := config.Rdb.HGet(ctx, consts.Room, req.Name).Bytes()
	if err != nil {
		c.String(http.StatusInternalServerError, err.Error())
		return
	}

	err = json.Unmarshal(jsonData, r)
	if err != nil {
		c.String(http.StatusInternalServerError, err.Error())
		return
	}
	hlog.Infof("room info: %v", r)

	resp := new(room.JoinRoomResp)
	resp.RoomID = r.RoomID
	resp.Address = r.Host
	resp.Port = r.Port
	resp.PlayerID = uid
	resp.MaxPlayer = r.MaxPlayer
	resp.RoomName = r.Name
	resp.PlayerName = kuser.User.Username

	c.JSON(http.StatusOK, resp)
}

// GetRoomList .
// @router /room [GET]
func GetRoomList(ctx context.Context, c *app.RequestContext) {
	var err error
	var req room.GetRoomListReq
	err = c.BindAndValidate(&req)
	if err != nil {
		c.String(http.StatusBadRequest, err.Error())
		return
	}

	var rooms = make([]*base.Room, 0)

	//get room from redis
	iter := config.Rdb.HScan(ctx, consts.Room, 0, "", 10).Iterator()
	var count = 0
	for iter.Next(ctx) {
		//unmarshal value
		if count%2 == 0 {
			count++
			continue
		}

		r := new(base.Room)
		//klog.Infof("key:%s, value:%s", iter.Val(), iter.Val())
		err = json.Unmarshal([]byte(iter.Val()), r)
		if err != nil {
			c.String(http.StatusInternalServerError, err.Error())
			return
		}
		rooms = append(rooms, r)
		count++
	}

	resp := new(room.GetRoomListResp)
	resp.Rooms = rooms

	c.JSON(http.StatusOK, resp)
}
