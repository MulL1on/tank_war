// Code generated by hertz generator.

package room

import (
	"context"
	"encoding/json"
	"github.com/cloudwego/hertz/pkg/app"
	"github.com/go-redis/redis/v8"
	"github.com/hashicorp/consul/api"
	"net/http"
	"tank_war/server/cmd/api/biz/model/base"
	"tank_war/server/cmd/api/biz/model/room"
	"tank_war/server/cmd/api/config"
	"tank_war/server/shared/consts"
)

// CreateRoom .
// @router /room [POST]
func CreateRoom(ctx context.Context, c *app.RequestContext) {
	var err error
	var req room.CreateRoomReq
	err = c.BindAndValidate(&req)
	if err != nil {
		c.String(http.StatusBadRequest, err.Error())
		return
	}
	resp := new(room.CreateRoomResp)

	//get room from redis
	err = config.Rdb.HGet(ctx, consts.Room, req.Name).Err()
	if err != nil {
		if err != redis.Nil {
			c.String(http.StatusInternalServerError, err.Error())
			return
		}
	} else {
		c.String(http.StatusBadRequest, "room name already exists")
		return
	}
	r := base.Room{
		Name:          req.Name,
		MaxPlayer:     req.MaxPlayer,
		CurrentPlayer: 1,
	}
	jsonData, err := json.Marshal(r)
	if err != nil {
		c.String(http.StatusInternalServerError, err.Error())
		return
	}

	err = config.Rdb.HSet(ctx, consts.Room, req.Name, jsonData).Err()
	if err != nil {
		c.String(http.StatusInternalServerError, err.Error())
		return
	}
	c.JSON(http.StatusOK, resp)
}

// JoinRoom .
// @router /room/join [POST]
func JoinRoom(ctx context.Context, c *app.RequestContext) {
	var err error
	var req room.JoinRoomReq
	err = c.BindAndValidate(&req)
	if err != nil {
		c.String(http.StatusBadRequest, err.Error())
		return
	}
	var r = &base.Room{}
	//get room from redis
	jsonData, err := config.Rdb.HGet(ctx, consts.Room, req.Name).Bytes()
	if err != nil {
		c.String(http.StatusInternalServerError, err.Error())
		return
	}

	err = json.Unmarshal(jsonData, r)
	if err != nil {
		c.String(http.StatusInternalServerError, err.Error())
		return
	}
	r.CurrentPlayer++

	jsonData, err = json.Marshal(r)

	err = config.Rdb.HSet(ctx, consts.Room, req.Name, r, 0).Err()
	if err != nil {
		c.String(http.StatusInternalServerError, err.Error())
		return
	}
	resp := new(room.JoinRoomResp)

	//TODO: get a free quic server address and port
	config := api.DefaultConfig()
	client, err := api.NewClient(config)
	if err != nil {
		c.String(http.StatusInternalServerError, err.Error())
		return
	}
	services, _, err := client.Catalog().Service(consts.GameServer, "", nil)
	if err != nil {
		c.String(http.StatusInternalServerError, err.Error())
		return
	}

	for _, service := range services {
		if service.ServiceMeta["status"] == "free" {
			resp.Address = service.Address
			resp.Port = int32(service.ServicePort)
			c.JSON(http.StatusOK, resp)
			return
		}
	}

	c.JSON(http.StatusInternalServerError, "quic server not found")
}

// GetRoomList .
// @router /room [GET]
func GetRoomList(ctx context.Context, c *app.RequestContext) {
	var err error
	var req room.GetRoomListReq
	err = c.BindAndValidate(&req)
	if err != nil {
		c.String(http.StatusBadRequest, err.Error())
		return
	}

	var rooms = make([]*base.Room, 0)

	//get room from redis
	iter := config.Rdb.HScan(ctx, consts.Room, 0, "", 10).Iterator()
	var count = 0
	for iter.Next(ctx) {
		//unmarshal value
		if count%2 == 0 {
			count++
			continue
		}

		r := new(base.Room)
		//klog.Infof("key:%s, value:%s", iter.Val(), iter.Val())
		err = json.Unmarshal([]byte(iter.Val()), r)
		if err != nil {
			c.String(http.StatusInternalServerError, err.Error())
			return
		}
		rooms = append(rooms, r)
		count++
	}

	resp := new(room.GetRoomListResp)
	resp.Rooms = rooms

	c.JSON(http.StatusOK, resp)
}
